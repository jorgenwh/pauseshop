# URL Reconstruction Guide

This document explains how to decode and reconstruct the optimized referrer URLs generated by the PauseShop extension.

## URL Structure

The complete referrer URL has the following format:
```
{baseUrl}/referrer?pauseId={sessionId}&data={encodedData}
```

Example:
```
https://pauseshop.net/referrer?pauseId=session-123&data=710PSL6OBTLB0CB3VXLPZ3799#1|710PSL6OBTLB0CB3VXLPZ3799|61abc123DEFB07XJ8C8F54550
```

## Encoded Data Format

The `data` parameter uses a custom fixed-length encoding optimized for our specific data structure. **No separators are needed** because Amazon ASINs and image IDs are always the same length!

### Format Structure
```
{clickedProduct}#{clickPosition}|{product1}|{product2}|{product3}|...
```

Where:
- `clickedProduct` - The actual product that was clicked (full product data)
- `#` - Separator between clicked product and position/context
- `clickPosition` - Index of clicked product in the products array (for context)
- `|` - Separator between sections
- `product1, product2...` - All scraped products for context

### Product Format
Each product follows this fixed-length pattern:
```
{imageId11}{asin10}[{priceInCents}]
```

Where:
- `imageId` (required): Amazon image identifier, always 11 characters (e.g., "710PSL6OBTL")
- `asin` (optional): Amazon ASIN, always 10 characters when present (e.g., "B0CB3VXLPZ")
- `priceInCents` (optional): Price in cents as digits only (e.g., "3799" for $37.99)

**Key Insight**: Since imageId and ASIN have fixed lengths, we can determine the structure by total length:
- Length = 11: imageId only
- Length = 21: imageId + asin (no price)
- Length > 11 and < 21: imageId + price (no asin)
- Length > 21: imageId + asin + price

**Key insight**: Since image IDs are always 11 chars and ASINs are always 10 chars, we can parse them by position without separators!

### Examples

#### Complete Product Data
```
710PSL6OBTLB0CB3VXLPZ3799
```
- Characters 1-11: Image ID `710PSL6OBTL`
- Characters 12-21: ASIN `B0CB3VXLPZ`
- Characters 22+: Price `3799` (37.99)

#### Product Without Price
```
710PSL6OBTLB0CB3VXLPZ
```
- Characters 1-11: Image ID `710PSL6OBTL`
- Characters 12-21: ASIN `B0CB3VXLPZ`
- Price: Not available

#### Product Without ASIN
```
710PSL6OBTL3799
```
- Characters 1-11: Image ID `710PSL6OBTL`
- Characters 12+: Price `3799` ($37.99)
- ASIN: Not available (length is 15, not 21)

#### Product With Only Image ID
```
710PSL6OBTL
```
- Characters 1-11: Image ID `710PSL6OBTL`
- ASIN: Not available
- Price: Not available

## Decoding Algorithm

### Step 1: Parse URL Parameters
Extract `pauseId` and `data` from the URL query parameters.

### Step 2: Split Encoded Data
Split the `data` parameter to extract components:
```javascript
// First split by '#' to separate clicked product from the rest
const [clickedProductStr, remainder] = encodedData.split('#');

// Then split remainder by '|' to get position and context products
const remainderParts = remainder.split('|');
const clickedPosition = parseInt(remainderParts[0], 10);
const contextProductParts = remainderParts.slice(1);
```

### Step 3: Parse Each Product
For each product string, extract the components using fixed-length parsing:

```javascript
function parseProduct(productStr) {
    // Extract image ID (always first 11 characters)
    const imageId = productStr.substring(0, 11);
    
    // Determine structure based on length
    let asin = undefined;
    let price = undefined;
    
    if (productStr.length === 11) {
        // Only imageId
    } else if (productStr.length === 21) {
        // imageId + asin (no price)
        asin = productStr.substring(11, 21);
    } else if (productStr.length > 11 && productStr.length < 21) {
        // imageId + price (no asin)
        const priceStr = productStr.substring(11);
        price = parseInt(priceStr, 10) / 100; // Convert cents to dollars
    } else if (productStr.length > 21) {
        // imageId + asin + price
        asin = productStr.substring(11, 21);
        const priceStr = productStr.substring(21);
        price = parseInt(priceStr, 10) / 100; // Convert cents to dollars
    }
    
    return { imageId, asin, price };
}
```

### Step 4: Reconstruct Amazon URLs
Convert the parsed data back to full Amazon URLs:

```javascript
function reconstructThumbnailUrl(imageId) {
    return `https://m.media-amazon.com/images/I/${imageId}._AC_UL320_.jpg`;
}

function reconstructProductUrl(asin) {
    return asin ? `https://www.amazon.com/dp/${asin}` : null;
}
```

## Complete Decoding Example

```javascript
function decodeReferrerData(encodedData) {
    // Split by '#' to separate clicked product from the rest
    const [clickedProductStr, remainder] = encodedData.split('#');
    
    // Parse the clicked product
    const { imageId: clickedImageId, asin: clickedAsin, price: clickedPrice } = parseProduct(clickedProductStr);
    const clickedProduct = {
        imageId: clickedImageId,
        amazonAsin: clickedAsin,
        thumbnailUrl: reconstructThumbnailUrl(clickedImageId),
        productUrl: clickedAsin ? reconstructProductUrl(clickedAsin) : null,
        price: clickedPrice
    };
    
    // Split remainder by '|' to get position and context products
    const remainderParts = remainder.split('|');
    const clickedPosition = parseInt(remainderParts[0], 10);
    const contextProductParts = remainderParts.slice(1);
    
    // Parse context products
    const contextProducts = [];
    for (const productStr of contextProductParts) {
        if (!productStr) continue;
        
        const { imageId, asin, price } = parseProduct(productStr);
        
        contextProducts.push({
            imageId,
            amazonAsin: asin,
            thumbnailUrl: reconstructThumbnailUrl(imageId),
            productUrl: asin ? reconstructProductUrl(asin) : null,
            price
        });
    }
    
    return {
        clickedProduct,
        clickedPosition,
        contextProducts
    };
}

// Example usage:
const encodedData = "710PSL6OBTLB0CB3VXLPZ3799#1|710PSL6OBTLB0CB3VXLPZ3799|61abc123DEFB07XJ8C8F54550";
const decoded = decodeReferrerData(encodedData);
console.log(decoded);
```

## Size Optimization Benefits

This custom encoding provides significant size reduction compared to JSON + Base64:

### Example Comparison
For 3 products with full data:

**Old Method (JSON + Base64):**
```
eyJjIjoxLCJwIjpbeyJpIjoiNzEwUFNMNk9CVEwiLCJhIjoiQjBDQjNWWExQWiIsInAiOjM3Ljk5fSx7ImkiOiI2MWFiYzEyM0RFRiIsImEiOiJCMDdYSjhDOEY1IiwicCI6NDUuNX0seyJpIjoiNzF4eXo3ODlHSEkiLCJhIjoiQjA5QUJDRDEyMzQiLCJwIjoxMi43NX1dfQ
```
Length: ~200 characters

**New Method (Fixed-Length Encoding with Clicked Product):**
```
710PSL6OBTLB0CB3VXLPZ3799#1|710PSL6OBTLB0CB3VXLPZ3799|61abc123DEFB07XJ8C8F54550|71xyz789GHIB09ABCD12341275
```
Length: ~102 characters

**Savings: ~49% reduction in encoded data size**

Note: The clicked product data adds some length but provides complete product information without relying on the context array position.

## Backward Compatibility

The website should detect and handle both formats:

1. **New Format**: Contains pipe characters and uses fixed-length encoding
2. **Legacy Format**: Base64-encoded JSON (for existing URLs)

```javascript
function isLegacyFormat(encodedData) {
    return encodedData.match(/^[A-Za-z0-9+/\-_=]+$/) && encodedData.length > 50 && !encodedData.includes('|');
}

function isFixedLengthFormat(encodedData) {
    return encodedData.includes('#') && encodedData.includes('|');
}
```

## Error Handling

- Invalid click position: Default to 0
- Missing image ID: Skip the product
- Invalid price format: Set price to undefined
- Invalid ASIN format: Set ASIN to undefined

## Security Considerations

- Validate all extracted data before use
- Sanitize image IDs and ASINs to prevent injection attacks
- Ensure price values are reasonable (e.g., 0-999999 cents)
- Limit the number of products to prevent abuse (e.g., max 50 products)

## Testing

A test file `encoding-test-example.js` is provided to demonstrate the optimization benefits. Run it in a browser console to see the dramatic size reduction compared to traditional JSON + Base64 encoding.

## Implementation Notes

- The extension only encodes data; it never needs to decode
- All decoding logic should be implemented on the website side
- The custom format is URL-safe and doesn't require additional encoding
- Backward compatibility with old Base64 format can be detected by checking for pipe characters